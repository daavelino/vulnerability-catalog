/*
 * Panorama constructor using d3.js, dc.js an crossfilter.js
 */
url = "/catalog/vulnerability/data/panorama/json"

// Getting data to visualize:
d3.json(url, function(error, data) {
  if (error) throw error; 

  // Grouping all data into the ndx index: 
  var ndx = crossfilter(data);

  // I prefer to group all chart related variables instead of define it in the top of the code.
  ////////////////////////////
  ////////// Perimeter chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.rowChart.html
  ////////////////////////////
  var perimeterChart = dc.rowChart("#perimeterChart");
  var perimeterDim = ndx.dimension(function (d) { return d["perimeter"]; })
  var perimeterGroup = perimeterDim.group();

  perimeterChart
    .x(d3.scale.linear(perimeterDim))
    .dimension(perimeterDim)
    .group(perimeterGroup)
    .elasticX(true)
    .label(function(d){ // https://stackoverflow.com/questions/30465870
            return d.key + ": " + (d.value / ndx.groupAll().reduceCount().value() * 100).toFixed(0) + "%";
        })
    .controlsUseVisibility(true);

  ////////////////////////////
  ////////// Status chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.pieChart.html
  ////////////////////////////
  var statusChart = dc.pieChart("#statusChart");
  var statusDim = ndx.dimension(function (d) { return d["status"]; })
  var statusGroup = statusDim.group();

  statusChart
    .dimension(statusDim)
    .group(statusGroup)
    .legend(dc.legend())
    .colors(d3.scale.ordinal()
      .domain(['Accepted', 'Mitigated', 'Not identified', 'Notified', 'Solved'])
      .range(['#868e96','#007bff','#dc3545','#ffc107','#28a745'])) // Bootstrap4 colors.
    .label(function(d){ // https://stackoverflow.com/questions/30465870
            return (d.value / ndx.groupAll().reduceCount().value() * 100).toFixed(0) + "%";
        })
    .controlsUseVisibility(true);

  ////////////////////////////
  ////////// System chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.rowChart.html
  ////////////////////////////
  var systemChart = dc.rowChart("#topSystemsChart");
  var systemDim = ndx.dimension(function (d) { return d["system"]; });
  var systemGroup = systemDim.group();

  systemChart
    .dimension(systemDim)
    .group(systemGroup)
    .elasticX(true)
    // http://colorbrewer2.org/#type=sequential&scheme=PuRd&n=9
    .colors(d3.scale.ordinal().range(['#ce1256','#e7298a','#df65b0','#c994c7','#d4b9da','#e7e1ef','#f7f4f9']))
    .data(function (group) { return group.top(5); })
    .controlsUseVisibility(true)


  ////////////////////////////
  ////////// Severity chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.rowChart.html
  ////////////////////////////
  var severityChart = dc.lineChart("#severityChart");
  var severityDim = ndx.dimension(function (d) { return d["cvss_value"]; });
  var severityGroup = severityDim.group();

  severityChart
    .dimension(severityDim)
    .group(severityGroup)
    .x(d3.scale.linear().domain([0,10]))
    .brushOn(false)
    .yAxisLabel("# of Vulnerabilities")
    .xAxisLabel("CVSS 3.0 score")
    .xyTipsOn(true)
    .renderArea(true)
    .elasticX(true)
    .controlsUseVisibility(true);
    


  ////////////////////////////
  ///////// Risk chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.pieChart.html
  ////////////////////////////
  var riskChart = dc.pieChart("#riskChart");
  var riskDim = ndx.dimension(function (d) { return d["risk"]; })
  var riskGroup = riskDim.group();

  riskChart
    .dimension(riskDim)
    .group(riskGroup)
    .legend(dc.legend())
    // http://colorbrewer2.org/#type=sequential&scheme=OrRd&n=4
    .colors(d3.scale.ordinal()
      .domain(['Critical', 'High', 'Medium', 'Low'])
      .range(['#343a40','#dc3545','#ffc107','#868e96']))
    .label(function(d){ // https://stackoverflow.com/questions/30465870
            return (d.value / ndx.groupAll().reduceCount().value() * 100).toFixed(0) + "%";
        })
    .controlsUseVisibility(true);

  ////////////////////////////
  ////////// category chart:
  ////////////////////////////
  // https://dc-js.github.io/dc.js/docs/html/dc.dataTable.html
  var categoryChart = dc.dataTable("#topCategoriesChart");
  var categoryDim = ndx.dimension(function (d) { return d["category"]; });
  var categoryGroup = categoryDim.group();

  var countOfCategories = categoryDim.group()
            .reduceCount(function(d) { return d["category"]; });

  categoryChart
    .dimension(countOfCategories)
    .group(function (d) { return '' })
    .columns([
      { label: "Top Categories", format:function (d) { return d.key; } },
      { label: "#", format:function (d) { return d.value; } },
       ])
    .sortBy(function (d) { return d.value; })
    .order(d3.descending) //https://github.com/dc-js/dc.js/issues/1115
    .size(5)
    .controlsUseVisibility(true);

  ////////////////////////////
  ////////// Bubble chart:
  ////////////////////////////
  // https://dc-js.github.io/dc.js/docs/html/dc.bubbleChart.html
  var bubbleChart = dc.bubbleChart("#ownersAndVulnerabilitiesChart");
  var ownersDim = ndx.dimension(function(d) { return d["owner"]; });

  //Reduce "system/vulnerabilities" entries:
  //
  // It uses the dict bubbleData as accumulator and counts, per owner:
  // - the total number of unique systems (totalSystems)
  // - the total number of vulnerabilities (totalVulnerabilities)
  function reduceBubbleAdd(p,v) {
    // counting unique systems associated with some owner:
    if (v.system in p.bubbleData) {
      p.bubbleData[v.system] += 1;
    } else {
      p.bubbleData[v.system] = 1;
      p.bubbleData["totalSystems"] += 1;
    }

    // counting unique associated vulnerabilities:
    p.bubbleData["totalVulnerabilities"] += 1; //Vuls are unique.
    return p;
  }

  function reduceBubbleRemove(p,v) {
    if (! v.system in p.bubbleData) // We add it just if v.system exists.
      p.bubbleData["totalSystems"] -= 1;
    else
      p.bubbleData["totalVulnerabilities"] -= 1;

    // Cleaning the accumulator:
    if (p.bubbleData["totalSystems"] === 0)
      delete p.bubbleData[v.system];
    return p;
  }

  function reduceBubbleInitial() {
    return {bubbleData:{totalSystems:0, totalVulnerabilities:0}};
  }

   var ownersGroup = ownersDim.group();
   var bubbleGroup = ownersDim.group()
           .reduce(reduceBubbleAdd, reduceBubbleRemove, reduceBubbleInitial);

  bubbleChart
    .dimension(ownersDim)
    .group(bubbleGroup)
    .keyAccessor(function (d) { //x-axis values:
      return d.value["bubbleData"]["totalVulnerabilities"]; } )
    .valueAccessor(function (d) { //y-axis values:
      return d.value["bubbleData"]["totalSystems"]; } )
    .radiusValueAccessor(function (d) { //ball-size values:
      return d.value["bubbleData"]["totalVulnerabilities"] } )
    .r(d3.scale.linear().domain([0, data.len])) // vuls are unique...
    .x(d3.scale.linear().domain([0, data.len]))
    .minRadiusWithLabel(10)
    .elasticX(true)
    .elasticY(true)
    .elasticRadius(true)
    .yAxisPadding(1)
    .xAxisPadding(1)
    .yAxisLabel("# Systems")
    .xAxisLabel("# Vulnerabilities")
    .maxBubbleRelativeSize(0.05)
    .renderHorizontalGridLines(true)
    .renderVerticalGridLines(true)
    .controlsUseVisibility(true);
  
  ////////////////////////////
  ////////// Time Overall chart:
  ////////////////////////////
  // https://dc-js.github.io/dc.js/docs/html/dc.lineChart.html
  var overallChart = dc.compositeChart("#overallChart");

  // Please check at https://github.com/dc-js/dc.js/issues/878
  // for a bug preventing brush filter to work properly on multiline 
  // charts.

  // Set the range of time x-axis:
  var timeParser = d3.time.format("%Y-%m-%d");
  var min = timeParser.parse("9999-99-99") ;
  var max = timeParser.parse("0000-00-00");
  for (var i in data) {
    var tmp = timeParser.parse(data[i]["identification_date"]);
    if (tmp <= min) {
      min = tmp;
    }
    if (tmp >= max) {
      max = tmp;
    }
  }

  var overallDim = ndx.dimension(function(d) { return timeParser.parse(d["identification_date"]); });

//console.log(overallDim.top(5));

  // I was unable to pass the status value as a parameter
  // so I had to reduce one by one:

  //Reduce "Solved"  entries:
  function reduceSolvedAdd(p,v) {
    if (v['status'] == "Solved")
      p.status += +1;
    return p;
  }

  function reduceSolvedRemove(p,v) {
    if (v['status'] == "Solved")
      p.status -= +1;
    return p;
  }

  //Reduce "Notified"  entries:
  function reduceNotifiedAdd(p,v) {
    if (v['status'] == "Notified")
      p.status += +1;
    return p;
  }

  function reduceNotifiedRemove(p,v) {
    if (v['status'] == "Notified")
      p.status -= +1;
    return p;
  }

  //Reduce "Mitigated"  entries:
  function reduceMitigatedAdd(p,v) {
    if (v['status'] == "Mitigated")
      p.status += +1;
    return p;
  }

  function reduceMitigatedRemove(p,v) {
    if (v['status'] == "Mitigated")
      p.status -= +1;
    return p;
  }

  //Reduce "Not identified"  entries:
  function reduceNIdentifiedAdd(p,v) {
    if (v['status'] == "Not identified")
      p.status += +1;
    return p;
  }

  function reduceNIdentifiedRemove(p,v) {
    if (v['status'] == "Not identified")
      p.status -= +1;
    return p;
  }

  //Reduce "Risk accepted"  entries:
  function reduceRiskAcceptedAdd(p,v) {
    if (v['status'] == "Risk accepted")
      p.status += +1;
    return p;
  }

  function reduceRiskAcceptedRemove(p,v) {
    if (v['status'] == "Risk accepted")
      p.status -= +1;
    return p;
  }

  function reduceInitial() {
    return {
      identification_date:0,
      status:0
    };
  }

   var notifiedGroup = overallDim.group()
       .reduce(reduceNotifiedAdd, reduceNotifiedRemove, reduceInitial);
   
   var solvedGroup = overallDim.group()
       .reduce(reduceSolvedAdd, reduceSolvedRemove, reduceInitial);

   var mitigatedGroup = overallDim.group()
       .reduce(reduceMitigatedAdd, reduceMitigatedRemove, reduceInitial);

   var nIdentifiedGroup = overallDim.group()
       .reduce(reduceNIdentifiedAdd, reduceNIdentifiedRemove, reduceInitial);

   var riskAcceptedGroup = overallDim.group()
       .reduce(reduceRiskAcceptedAdd, reduceRiskAcceptedRemove, reduceInitial);

   overallChart
     .brushOn(false) // Fails at compose: https://github.com/dc-js/dc.js/issues/878
     .x(d3.time.scale().domain([min, max]))
     .yAxisLabel("Vulnerabilities")
     .elasticX(true)
     .renderVerticalGridLines(true)
     .renderHorizontalGridLines(true)
     .legend(dc.legend().x(50).autoItemWidth(true).horizontal(true))
     .compose([
        dc.lineChart(overallChart)
          .dimension(overallDim)
          .renderArea(true)
          .renderDataPoints(true)
          .colors('Gold')
          .valueAccessor(function (d) { return d.value.status })
          .group(notifiedGroup, "Notif."),

        dc.lineChart(overallChart)
          .dimension(overallDim)
          .renderArea(true)
          .renderDataPoints(true)
          .colors('Green')
          .valueAccessor(function (d) { return d.value.status })
          .group(solvedGroup, "Solv."),

        dc.lineChart(overallChart)
          .dimension(overallDim)
          .renderArea(true)
          .renderDataPoints(true)
          .colors('Blue')
          .valueAccessor(function (d) { return d.value.status })
          .group(mitigatedGroup, "Mitig."),

        dc.lineChart(overallChart)
          .dimension(overallDim)
          .renderArea(true)
          .renderDataPoints(true)
          .colors('Crimson')
          .valueAccessor(function (d) { return d.value.status })
          .group(nIdentifiedGroup, "Not ident."),

        dc.lineChart(overallChart)
          .dimension(overallDim)
          .renderArea(true)
          .renderDataPoints(true)
          .colors('Grey')
          .valueAccessor(function (d) { return d.value.status })
          .group(riskAcceptedGroup, "Accept."),
     ])

  // Rendering all charts:
//  dc.renderAll();
  perimeterChart.render();
  statusChart.render();
  riskChart.render();
  categoryChart.render();
  severityChart.render();
  systemChart.render();
  bubbleChart.render();
  overallChart.render();

});
