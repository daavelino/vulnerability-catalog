/* html.helper.js: 
 * here are some javascript functions to enable html features.
 */

function getURLParameters() {
  // Returns an array = [[param1, value1], [param2, value2],...]
  // presentet at the _current_ URL's query string: ?param1=value1&...
  // No parameteres are required.

  // Getting the current url:
  var url = window.location;

  // Getting the parameters from the query string:
  var params = url.search.substring(1);

  // Ensuring it works even with a single parameter:
  if (params.includes("&")) {
    params = params.split("&");
  } else {
    var tmp = [];
    tmp.push(params);
    params = tmp;
  }
  // Create an array containing the result:
  params = params.map(v => v.split("="));
  return params;
}

function movePage(url, direction) {
  // Given an url, it sets a query string with ?start=x&stop=y 
  // to it when direction ('next' or 'previous' button) is clicked
  // and points the User-agent to the new url.
  // It uses getUrlParameters() function to get the desired direction.
  // Usage:
  // movePage(url, next) or movePage(url, previous)

  var newUrl, params, start, stop, i;
  var allowedParameters = ["next", "previous"];
  var steps = 10; //10 entries per table in the default mode.

  //Ensures that a given 'value' is present at 'testArray':
  function checkParameters(testArray, value) {
    return testArray.some(x => x === value);
  }

  if (!checkParameters(allowedParameters, direction)) {
    console.log("Parameters are 'next' or 'previous'.");
  }

  params = getURLParameters();

  // Checking to get our values. 
  for (i in params) {
    if (params[i][0] == "start") {
      start = params[i][1];
    }
    if (params[i][0] == "stop") {
      stop = params[i][1];
    }
  }
  // Construct the desired URL:
  if (start) {
    if (direction == "next") {
      start = parseInt(start) + parseInt(steps);
    } 
    if (direction == "previous") {// it is just a sign (plus/minus) change.
      start = parseInt(start) - parseInt(steps);
    }
    if (start >= 0) {
      start = String(start);
    } else {
      start = "0";
    }
    newUrl = url + "?start=" + start;
  }

  if (stop) {
    if (direction == "next") {
      stop = parseInt(stop) + parseInt(steps);
    }
    if (direction == "previous") {
      stop = parseInt(stop) - parseInt(steps);
    }
    
    if (stop >= 0) {
      stop = String(stop);
    } else {
      stop = steps;
    }
    newUrl = url + "?start=" + start + "&stop=" + stop;
  }

  if (!start) {
    newUrl = url + "?start=" + steps;
  }

  // point UA to the desired URL:
  document.location.assign(newUrl);
}

function sortTable(n, tableName) {
  // Sort table data <td> by using the table row 'n' as index.
  // It just sort text data. Dates are treating as text sentences.
  // If table is already sorted, it reverts the data order.
  // The variable 'tableIndex' is a matrix that takes the row n
  // and stores all row text data (tableIndex[0]) and its respective <tr> 
  // objects (tableIndex[1]). So, it is possible to sort data using 
  // tableIndex[0] and keep track of the row data associated to it.
  // In some sense, it works like a matrix representation of the table data,
  // identified by row n data.
  // Take a look at console.log() to see how it works.

  var table, rows, tmp, tmpData, i;
  var tableIndex = [];
  var tableIndexGiven = [];
  var tableIndexFinal = [];
  var orderIt = false;
  var isDate = false;

  // Getting data to be sorted:
  table = document.getElementById(tableName);
  rows = table.getElementsByTagName("tr");

  // Get all table data <td> of the n-th row and, 
  // for each entry, store its <tr> data into tableIndex[]:
  for (i = 1; i < (rows.length); i++) {
    tmp = rows[i].getElementsByTagName("td")[n];
    tmpData = tmp.innerText.toLowerCase();
    // Check if data is a Date type:
    if (isNaN(Date.parse(tmpData)) == false) {
      isDate = true; // isNaN checks if arg is Not a Number.
      console.log("is date", tmpData);
    } else {
      isDate = false;
    }
    tableIndex.push([tmpData, rows[i], isDate]);
  }
//  console.log(tableIndex);
  // Keep track of table data order before try to sort it:
  tableIndexGiven = tableIndex.slice();

  // Sort row n elements data:
  tableIndex = tableIndex.sort(function(a, b) {
    if (isDate == false) {
      if (a < b) {
        return 1;
      }
      if (a > b) {
        return -1;
      }
      return 0; // if a == b:
    } else {
      // b[0] and a[0] are the tableIndex element containing date string.
      return = Date.parse(b[0]) - Date.parse(a[0]);
    } 
  });
 
  // Test to see if row n elements are already sorted:
  for (i = 0; i < (rows.length - 1); i++) {
    if (tableIndexGiven[i][0] != tableIndex[i][0]) {
       orderIt = true;
       break
    }
  }

  // If it is not sorted, use sorted data. Else,
  // revert data order:
  if (orderIt) {
    tableIndexFinal = tableIndex;
  } else {
    tableIndexFinal = tableIndex.reverse();
  }

  // Presenting the new table data order:
  for (i = 1; i < (rows.length - 1); i++) {
     rows[i].parentNode.insertBefore(tableIndexFinal[i - 1][1], rows[i]);
  } 
}

/* End of html.helper.js */
