/* 
html.helper.js: 
Some javascript functions to enable html presentation features.
 */

function getURLParameters() {
  // Returns an array = [[param1, value1], [param2, value2],...]
  // presented by the _current_ URL's query string: ?param1=value1&...
  // No parameteres are required.

  // Getting the current url:
  var url = window.location;

  // Getting the parameters from the query string:
  var params = url.search.substring(1);

  // Ensuring it works even with a single parameter:
  if (params.includes("&")) {
    params = params.split("&");
  } else {
    var tmp = [];
    tmp.push(params);
    params = tmp;
  }
  // Create an array containing the result:
  params = params.map(v => v.split("="));
  return params;
}

function checkParameters(value, testArray) {
  //Ensures that a given 'value' is present at some'testArray':
  return testArray.some(x => x === value);
}

function movePage(url, direction) {
  // Given an url, it sets a query string with ?start=x&stop=y 
  // to it when direction ('next' or 'previous' button) is clicked
  // and points the User-agent to the new url.
  // It uses getUrlParameters() function to get the desired direction.
  // Usage:
  // movePage(url, next) or movePage(url, previous)

  var newUrl, params, start, stop, i;
  var allowedParameters = ["next", "previous"];
  var steps = 10; //10 entries per table in the default mode.


  if (!checkParameters(direction, allowedParameters)) {
    console.log("Parameters are 'next' or 'previous'.");
  }

  params = getURLParameters();
  // Checking to get our values. 
  for (i in params) {
    if (params[i][0] == "start") {
      start = params[i][1];
    }
    if (params[i][0] == "stop") {
      stop = params[i][1];
    }
  }
  // Construct the desired URL:
  if (start) {
    if (direction == "next") {
      start = parseInt(start) + parseInt(steps);
    } 
    if (direction == "previous") {// it is just a sign (plus/minus) change.
      start = parseInt(start) - parseInt(steps);
    }
    if (start >= 0) {
      start = String(start);
    } else {
      start = "0";
    }
    newUrl = url + "?start=" + start;
  }

  if (stop) {
    if (direction == "next") {
      stop = parseInt(stop) + parseInt(steps);
    }
    if (direction == "previous") {
      stop = parseInt(stop) - parseInt(steps);
    }
    
    if (stop >= 0) {
      stop = String(stop);
    } else {
      stop = steps;
    }
    newUrl = url + "?start=" + start + "&stop=" + stop;
  }

  if (!start) {
    newUrl = url + "?start=" + steps;
  }

  // point UA to the desired URL:
  document.location.assign(newUrl);
}

function sortTable(n, tableName) {
  // Sort table data <td> by using the table row 'n' as index.
  // It just sort text data. Dates are treating as text sentences.
  // If table is already sorted, it reverts the data order.
  // The variable 'tableIndex' is a matrix that takes the row n
  // and stores all row text data (tableIndex[0]) and its respective <tr> 
  // objects (tableIndex[1]). So, it is possible to sort data using 
  // tableIndex[0] and keep track of the row data associated to it.
  // In some sense, it works like a matrix representation of the table data,
  // identified by row n data.
  // Take a look at console.log() to see how it works.

  var table, rows, tmp, tmpData, i;
  var tableIndex = [];
  var tableIndexGiven = [];
  var tableIndexFinal = [];
  var orderIt = false;
  var isDate = false;

  // Getting data to be sorted:
  table = document.getElementById(tableName);
  rows = table.getElementsByTagName("tr");

  // Get all table data <td> of the n-th row and, 
  // for each entry, store its <tr> data into tableIndex[]:
  for (i = 1; i < (rows.length); i++) {
    tmp = rows[i].getElementsByTagName("td")[n];
    tmpData = tmp.innerText.toLowerCase();
    // Check if data is a Date type:
    if (isNaN(Date.parse(tmpData)) == false) {
      isDate = true; // isNaN checks if arg is Not a Number.
      console.log("is date", tmpData);
    } else {
      isDate = false;
    }
    tableIndex.push([tmpData, rows[i], isDate]);
  }
  // console.log(tableIndex);
  // Keep track of table data order before try to sort it:
  tableIndexGiven = tableIndex.slice();

  // Sort row n elements data:
  tableIndex = tableIndex.sort(function(a, b) {
    if (isDate == false) {
      if (a < b) {
        return 1;
      }
      if (a > b) {
        return -1;
      }
      return 0; // if a == b:
    } else {
      // b[0] and a[0] are the tableIndex element containing date string.
      return Date.parse(b[0]) - Date.parse(a[0]);
    } 
  });
 
  // Test to see if row n elements are already sorted:
  for (i = 0; i < (rows.length - 1); i++) {
    if (tableIndexGiven[i][0] != tableIndex[i][0]) {
       orderIt = true;
       break
    }
  }

  // If it is not sorted, use sorted data. Else,
  // revert data order:
  if (orderIt) {
    tableIndexFinal = tableIndex;
  } else {
    tableIndexFinal = tableIndex.reverse();
  }

  // Presenting the new table data order:
  for (i = 1; i < (rows.length - 1); i++) {
     rows[i].parentNode.insertBefore(tableIndexFinal[i - 1][1], rows[i]);
  } 
}

function postSearchData(field, filter, value, searchPageUrl) {
  /* 
  Performs a search at 'SearchPageUrl' page and present result at the current page. 
  It receives field ('Risk','Status', etc), a Django search filter 
  (__contains=, __in=, etc), the search desired value (High, Medium, ...) 
  and performs a search the same way Search function does. So, it present to
  the user the corresponding search results without change the current url.
  */
  
  var queryString = field + filter + value;
  var csrf_token = document
                  .getElementsByName("csrfmiddlewaretoken")[0]
                  .value;
  
  var formData = new FormData();
  formData.append("q", queryString);
  formData.append("csrfmiddlewaretoken", csrf_token);
  
  var xhr = new XMLHttpRequest();
  xhr.open("POST", searchPageUrl, true);
  xhr.send(formData);

  xhr.onload = function () {
    /*Go to the Catalog page with the result found.*/
    var newWindow = window.open("xhr.response", "_self",
    "resizable,scrollbars,status");
    newWindow.document.write(xhr.responseText);
  }
}
/* End of html.helper.js */
