from datetime import date
from json import JSONEncoder
from json import dumps as JSONDumps

from django.core import serializers
from django.db.models import Count
from django.http import HttpRequest, HttpResponse, HttpResponseRedirect
from django.http import HttpResponseForbidden, HttpResponseNotFound
from django.urls import reverse
from django.views.generic import View, ListView, DetailView

from .models import Vulnerability


login_url='catalog:login'

#########################################################################
#### Warning: All require catalog.read_vulnerability user permission.
#### https://github.com/daavelino/vulnerability-catalog/issues/1 
#########################################################################

#### Thanks to https://stackoverflow.com/questions/11875770/
class DateTimeEncoder(JSONEncoder):
    def default(self, o):
        if isinstance(o, date):
            return o.isoformat()
        return super(DateTimeEncoder, self).default(o)

class PanoramaJsonView(View):
    '''/catalog/vulnerability/data/panorama/json/'''
    '''
    Returns a JSON data necessary to compose DCJS filter.
    '''
    model = Vulnerability

    def result(HttpRequest):
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')
        
        required_fields = ['system', 
                          'owner', 
                          'environment', 
                          'perimeter', 
                          'cvss_value',
                          'category', 
                          'risk', 
                          'identification_date', 
                          'remediation_deadline', 
                          'status']

        qs = Vulnerability.objects.only(*required_fields) \
                                  .values(*required_fields)
        qs = list(qs)
        qs = JSONDumps(qs, cls=DateTimeEncoder)

        return HttpResponse(qs, content_type='application/json')    

class JsonFilterView(View):
    model = Vulnerability

    def get_data(HttpRequest, field=None, countby=None):
        '''/catalog/vulnerability/data/json/filter/?field=<field_name>&countby=<field_name>'''
        '''
        Returns a JSON filtered by field and countby.
        field_name respects the following allowed_fields[].
        '''
   
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')

        allowed_fields = ['system', 
                          'owner', 
                          'environment', 
                          'perimeter', 
                          'technology', 
                          'system_type', 
                          'vulnerability', 
                          'category', 
                          'cvss_score', 
                          'identification_date', 
                          'risk', 
                          'remediation_deadline', 
                          'status']
    
        field = HttpRequest.GET.get('field')
        countby =  HttpRequest.GET.get('countby')

        if field and (field not in allowed_fields):
            return HttpResponseNotFound()
        if countby and (countby not in allowed_fields):
            return HttpResponseNotFound()

        #### single field match:
        if field and not countby:
            data = Vulnerability.objects \
                                .values(field) \
                                .annotate(vulnerabilities=Count('id'))
            data = list(data)
            data = JSONDumps(data)

            return HttpResponse(data, content_type='application/json')
    
        #### double field match:
        if field and countby:
            data = Vulnerability.objects \
                                .values(field, countby) \
                                .annotate(vuls=Count(countby)) 
            data  = list(data)
            result = dict()
            for i in data:
                if i[field] not in result.keys():
                    result[str(i[str(field)])] = {
                        str(countby):{
                            str(i[str(countby)]): i['vuls']
                            }
                        }
                else:
                    tmp = result[i[field]]    
                    tmp[str(countby)].update({
                        str(i[str(countby)]):i['vuls']
                        })
                    result[str(i[str(field)])] = tmp

            #### Putting it in a d3-affordable format:
            tmp = list()
            for i in result.items():
                tmp.append({field:i[0],countby:i[1][countby]})
            result = JSONDumps(tmp)

            return HttpResponse(result, content_type='application/json')

class JsonDetailView(DetailView):
    '''/catalog/vulnerability/detail/json/<int:num>/'''
    '''
    Extracts a given vulnerability from database and returns a JSON
    representation of it.
    '''
    model = Vulnerability

    def result(HttpRequest, num):
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')

        qs = Vulnerability.objects.get(pk=num)
        qs = serializers.serialize('json', [qs])
        return HttpResponse(qs, content_type='application/json')
