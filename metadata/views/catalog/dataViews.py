import json
from datetime import date

from django.views.generic import View, ListView, DetailView
from django.core import serializers
from django.http import HttpRequest, HttpResponse, HttpResponseRedirect
from django.http import HttpResponseForbidden, HttpResponseNotFound
from django.urls import reverse
from django.db.models import Count

from .models import Vulnerability


login_url='catalog:login'

#########################################################################
#### Warning: requires catalog.read_vulnerability user permission.
#########################################################################

#### Thanks to https://stackoverflow.com/questions/11875770/
class DateTimeEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, date):
            return o.isoformat()
        return super(DateTimeEncoder, self).default(o)

class PanoramaJsonView(View):
    model = Vulnerability

    def result(HttpRequest):
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')
        
        required_fields = ['system', 
                          'owner', 
                          'environment', 
                          'perimeter', 
                          'cvss_value',
                          'category', 
                          'risk', 
                          'identification_date', 
                          'remediation_deadline', 
                          'status']

        qs = Vulnerability.objects.only(*required_fields) \
                                  .values(*required_fields)

        qs = list(qs)
        qs = json.dumps(qs, cls=DateTimeEncoder)

        return HttpResponse(qs, content_type='application/json')    

class JsonFilterView(View):
    model = Vulnerability

    def get_data(HttpRequest, field=None, countby=None):
        """ Usage: catalog/vulnerability/data/json/filter/?field=<field_name>&countby=<field_name>"""
        """ Returns a JSON with the counting of the Vulnerability model data."""
        """ field_name is one of the following allowed_fields: """

        #### https://github.com/daavelino/vulnerability-catalog/issues/1    
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')

        allowed_fields = ['system', 
                          'owner', 
                          'environment', 
                          'perimeter', 
                          'technology', 
                          'system_type', 
                          'vulnerability', 
                          'category', 
                          'cvss_score', 
                          'identification_date', 
                          'risk', 
                          'remediation_deadline', 
                          'status']
    
        field = HttpRequest.GET.get('field')
        countby =  HttpRequest.GET.get('countby')

        print(field, countby)

        if field and (field not in allowed_fields):
            return HttpResponseNotFound()
        if countby and (countby not in allowed_fields):
            return HttpResponseNotFound()

        #### single field match:
        if field and not countby:
            data = Vulnerability.objects \
                                .values(field) \
                                .annotate(vulnerabilities=Count('id'))
            data = list(data)
            data = json.dumps(data)

            return HttpResponse(data, content_type='application/json')
    
        #### double field match:
        if field and countby:
            data = Vulnerability.objects \
                                .values(field, countby) \
                                .annotate(vuls=Count(countby)) 
            data  = list(data)

            #### Generate json result properly:
            result = dict()
            for i in data:
                if i[field] not in result.keys():
                    result[str(i[str(field)])] = \
                        {str(countby):{str(i[str(countby)]): i['vuls']}}
                else:
                    tmp = result[i[field]]    
                    tmp[str(countby)].update({str(i[str(countby)]):i['vuls']})
                    result[str(i[str(field)])] = tmp

            #### Putting it in a d3-affordable format:
            tmp = list()
            for i in result.items():
                tmp.append({field:i[0],countby:i[1][countby]})

            result = json.dumps(tmp)
            return HttpResponse(result, content_type='application/json')

    
class JsonDataView(ListView):
    model = Vulnerability

    def dump_database(HttpRequest):
    ### catalog/vulnerability/data/json/dumpdatabase:
    ### Returns all database in the same format required to backup/import it.

        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')

        qs = list(Vulnerability.objects.all())
        qs = serializers.serialize('json', qs)
        return HttpResponse(qs, content_type='application/json')

class JsonDetailView(DetailView):
    ### An rendered template to show a given vulnerability in detail.
    model = Vulnerability

    def result(HttpRequest, num):
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')

        qs = Vulnerability.objects.get(pk=num)
        qs = serializers.serialize('json', [qs])
        return HttpResponse(qs, content_type='application/json')
