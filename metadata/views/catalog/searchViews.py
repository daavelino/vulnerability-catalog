import shlex

from django.views.generic import TemplateView
from django.http import HttpRequest, HttpResponse
from django.http import HttpResponseForbidden, HttpResponseRedirect
from django.urls import reverse
from django.shortcuts import render
from django.db.models import Q

from .models import Vulnerability

login_url='catalog:login'

#########################################################################
#### Read: requires catalog.read_vulnerability user permission.
#########################################################################

class SearchView(TemplateView):
    model = Vulnerability
    template_name = 'catalog/search.html'

    def search(HttpRequest):
        #### Unfortunately, decorators do not work here:
        if not HttpRequest.user.is_authenticated:
            return HttpResponseRedirect(reverse(login_url))
        if not HttpRequest.user.has_perm('catalog.read_vulnerability'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')

        search_string = HttpRequest.POST.get('q')
        if not search_string:
            #### Return a null Query set:
            qs = Vulnerability.objects.none()
            return render(HttpRequest, 
                          'catalog/search.html', 
                          {'vulnerability_list':qs})

        #### Parsing data to enable complex search filter:
        #### All lookuptyped searches parsed as dicts.
        lookuptype_search_list = list()
        #### All non lookuptyped searches parsed as dicts.
        ordinary_search_list = list() 
        wordlist = shlex.split(search_string) ## Each word in search string.
        #### If search_string is not in the field__lookuptype=value format, 
        #### search will be performed only in the following fields:
        default_search = ['vulnerability__icontains', 
                          'owner__icontains', 
                          'system__icontains'] 
         
        #### Django allowed lookuptype: 
        #### https://goo.gl/nz8SUo
        allowed_lookuptype = ['exact', 'iexact', 
                              'contains', 'icontains', 
                              'in',
                              'gt', 'gte', 
                              'lt', 'lte', 
                              'startswith', 'istartswith', 
                              'endswith', 'iendswith', 
                              'range', 
                              'date', 
                              'year', 'month', 'day', 'week', 
                              'week_day', 'quarter', 
                              'time', 'hour', 'minute', 'second', 
                              'isnull', 
                              'regex', 'iregex']

        #### All fields in models.py
        #### https://goo.gl/JZP36F
        #### https://goo.gl/B2PMUb
        allowed_fields = [i.name for i in Vulnerability._meta.get_fields()]

        #### Sanitizing and constructing the search_list for all search words:
        ## Each word in wordlist is either an ordinary word (possible enclosed
        ## by commas or a Django lookup field. To the first case, we simple 
        ## compose a query whose filter are in default_search list, e.g. 
        ## word1 => vulnerability_icontains=word1, owner_icontains=word1, etc.
        ##
        ## To the second case, the code has to ensure that word be exactly in 
        ## field__lookuptype=value format, with fields present in 
        ## allowed_fields list (all fields in database) and lookup_type in 
        ## allowed_lookuptype list, to avoid wrong queries be passed to 
        ## Django.
        for word in wordlist:
            #### if it _is_ a lookuptyped (field__lookuptype=value) word:
            if ('=' and '__') in word:
                tmp = word.split('=') #tmp[0]='field__lookuptype',tmp[1]='value'
                if len(tmp) == 2: #Check if only 1 '=' was passed.
                    lookuptype = tmp[0].lower() 
                    value = tmp[1]
                else:
                    lookuptype = ''
                    value = ''
                tmp = lookuptype.split('__') #Check if only 1 '_' was passed.
                if len(tmp) == 2: #tmp[0]=field,tmp[1]=lookupfield
                    field = tmp[0].lower()
                    lookup_splitted = tmp[1].lower() 
                else:
                    field = ''
                    lookuptype = ''
                if (field not in allowed_fields) or \
                   (lookup_splitted not in allowed_lookuptype):
                    # Preventing filter misuse
                    qs = Vulnerability.objects.none()
                    return render(HttpRequest, \
                                  SearchView.template_name, \
                                  {'vulnerability_list':qs})
                else: # Filter was passed right: filter__lookuptype=field
                  if '__in' in lookuptype: # The __in lookup field.
                      ### This case, value needs to be an iterable:
                      ## https://goo.gl/3XtKLC
                      value = value.replace('[','')
                      value = value.replace(']','')
                      value = value.split(',')
                  lookuptype_search_list.append({lookuptype:value})
            else: #### it is just an ordinary word to search:
                for lookuptype in default_search:
                    ordinary_search_list.append({lookuptype:word})
       
        if (len(lookuptype_search_list) or len(ordinary_search_list)) > 0:         
            #### Refining the query set: https://goo.gl/Je2sLs
            #### Non lookuptyped fields as an OR and lookuptyped as an AND:
            if (len(lookuptype_search_list) 
                and len(ordinary_search_list)) > 0:

                #### The OR filter: 
                ordinary_filter = Q()
                for i in ordinary_search_list:
                    ordinary_filter |= Q(**i)
               
                #### The AND filter over the OR filter: 
                qs_lookuptype = Vulnerability.objects.filter(ordinary_filter) 
                for i in lookuptype_search_list:
                    qs_lookuptype = qs_lookuptype.filter(**i)
                qs = qs_lookuptype

            elif len(ordinary_search_list) > 0:
                q_filter = Q()
                for i in ordinary_search_list:
                    q_filter |= Q(**i)
                
                qs = Vulnerability.objects
                qs = qs.filter(q_filter)

            elif len(lookuptype_search_list) > 0:
                qs = Vulnerability.objects 
                for i in lookuptype_search_list:
                    if not isinstance(i, dict):
                        qs = qs.filter(i)
                    else:
                        qs = qs.filter(**i)

            qs = qs.order_by('-identification_date')
            return render(HttpRequest, \
                          SearchView.template_name, \
                          {'vulnerability_list':qs})
            qs = qs.order_by('-identification_date')
        else:
            qs = Vulnerability.objects.none()
            qs = qs_ordinary
            return render(HttpRequest, \
                          SearchView.template_name, \
                          {'vulnerability_list':qs})
